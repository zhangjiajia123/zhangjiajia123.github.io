<!DOCTYPE html>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<!-- three.js library -->
<script src='examples/vendor/three.js/build/three.min.js'></script>
<!-- three.js GLTFLoader for loading 3D models -->
<script src='examples/vendor/three.js/examples/js/loaders/GLTFLoader.js'></script>
<!-- ar.js -->
<script src="build/ar.js"></script>
<script>THREEx.ArToolkitContext.baseURL = './'</script>

<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>
<div style='position: absolute; top: 10px; width:100%; text-align: center; z-index: 1;'>
	AR标记跟踪示例 - 点击模型可交互
</div>

<!-- 加载状态提示 -->
<div id="loading" style='position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 2; background: rgba(0,0,0,0.7); color: white; padding: 20px; border-radius: 5px; display: none;'>
	正在加载模型...
</div>

<script>
	//////////////////////////////////////////////////////////////////////////////////
	//		Init
	//////////////////////////////////////////////////////////////////////////////////

	// init renderer
	var renderer = new THREE.WebGLRenderer({
		antialias: true,
		alpha: true
	});
	renderer.setClearColor(new THREE.Color('lightgrey'), 0)
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.domElement.style.position = 'absolute'
	renderer.domElement.style.top = '0px'
	renderer.domElement.style.left = '0px'
	document.body.appendChild(renderer.domElement);

	// array of functions for the rendering loop
	var onRenderFcts = [];

	// init scene and camera
	var scene = new THREE.Scene();
	var camera = new THREE.Camera();
	scene.add(camera);

	// 用于存储加载的3D模型
	var loadedModel = null;
	var raycaster = new THREE.Raycaster();
	var mouse = new THREE.Vector2();
	var modelIsLoading = false;
	var selectedObject = null;
	var originalColor = null;
	
	// 模型加载函数
	function loadModel() {
		// 防止重复加载
		if (modelIsLoading || loadedModel) return;
		
		modelIsLoading = true;
		document.getElementById('loading').style.display = 'block';
		
		// 首先尝试加载GLTF模型
		// 注意：这里使用的是示例路径，用户需要替换为自己的模型路径
		// 如果没有现成的GLTF模型，我们将创建一个基本几何体作为后备
		
		// 创建一个简单的3D模型（立方体和球体的组合）作为示例
		// 在实际应用中，这里可以替换为加载真实的3D模型
		
		// 创建一个组来容纳所有模型元素
		var modelGroup = new THREE.Group();
		
		// 添加一个立方体
		var cubeGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
		var cubeMaterial = new THREE.MeshStandardMaterial({
			color: 0xff5500,
			metalness: 0.5,
			roughness: 0.5
		});
		var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
		cube.position.y = 0.25;
		modelGroup.add(cube);
		
		// 添加一个球体在立方体上方
		var sphereGeometry = new THREE.SphereGeometry(0.2, 32, 32);
		var sphereMaterial = new THREE.MeshStandardMaterial({
			color: 0x0055ff,
			metalness: 0.8,
			roughness: 0.2
		});
		var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
		sphere.position.y = 0.9;
		modelGroup.add(sphere);
		
		// 添加一些动画效果
		onRenderFcts.push(function(delta) {
			if (sphere) {
				sphere.rotation.y += delta * 2;
			}
			if (cube) {
				cube.rotation.x += delta;
				cube.rotation.z += delta;
			}
		});
		
		// 添加环境光以便更好地看到模型
		var ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
		modelGroup.add(ambientLight);
		
		// 添加方向光以产生阴影效果
		var directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
		directionalLight.position.set(1, 1, 1);
		modelGroup.add(directionalLight);
		
		// 将模型添加到场景中
		loadedModel = modelGroup;
		scene.add(loadedModel);
		
		// 设置模型的name属性，以便射线检测
		if (cube) cube.name = 'interactive-cube';
		if (sphere) sphere.name = 'interactive-sphere';
		
		// 隐藏加载提示
		setTimeout(function() {
			modelIsLoading = false;
			document.getElementById('loading').style.display = 'none';
			console.log('3D模型加载完成');
		}, 500);
		
		//  实际GLTF模型加载代码示例（需要替换为实际的模型路径）
		var loader = new THREE.GLTFLoader();
		loader.load(
			// 模型路径
			'models/scene.gltf',
			// 加载成功回调
			function(gltf) {
				loadedModel = gltf.scene;
				scene.add(loadedModel);
				
				// 为模型设置交互名称，这是点击事件检测的关键
				loadedModel.name = 'interactive-model';
				
				// 可以在这里设置模型的缩放、位置等
				loadedModel.scale.set(0.5, 0.5, 0.5);
				
				// 隐藏加载提示
				modelIsLoading = false;
				document.getElementById('loading').style.display = 'none';
				console.log('3D模型加载完成');
			},
			// 加载进度回调
			function(xhr) {
				console.log((xhr.loaded / xhr.total * 100) + '% 已加载');
			},
			// 加载错误回调
			function(error) {
				console.error('模型加载失败:', error);
				modelIsLoading = false;
				document.getElementById('loading').style.display = 'none';
			}
		);
	}

	////////////////////////////////////////////////////////////////////////////////
	//          handle arToolkitSource
	////////////////////////////////////////////////////////////////////////////////

	// 创建AR源（使用摄像头）
	var arToolkitSource = new THREEx.ArToolkitSource({
		sourceType: 'webcam',
	})

	arToolkitSource.init(function onReady(){
		onResize()
	})

	// 处理窗口大小变化
	window.addEventListener('resize', function(){
		onResize()
	})
	function onResize(){
		arToolkitSource.onResizeElement()
		arToolkitSource.copyElementSizeTo(renderer.domElement)
		if( arToolkitContext && arToolkitContext.arController !== null ){
			arToolkitSource.copyElementSizeTo(arToolkitContext.arController.canvas)
		}
	}

	////////////////////////////////////////////////////////////////////////////////
	//          initialize arToolkitContext
	////////////////////////////////////////////////////////////////////////////////

	// 创建AR工具包上下文
	var arToolkitContext = new THREEx.ArToolkitContext({
		cameraParametersUrl: THREEx.ArToolkitContext.baseURL + 'data/data/camera_para.dat',
		detectionMode: 'mono',
	})
	// 初始化AR上下文
	arToolkitContext.init(function onCompleted(){
		// 将投影矩阵复制到相机
		camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
	})

	// 标记检测状态变量
	var markerWasVisible = false;

	// 在每一帧更新AR工具包
	onRenderFcts.push(function(){
		if( arToolkitSource.ready === false ) return

		arToolkitContext.update(arToolkitSource.domElement)

		// 根据是否检测到标记来更新场景可见性
		scene.visible = camera.visible
		
		// 检查标记是否从不可见变为可见
		if (camera.visible && !markerWasVisible) {
			console.log('检测到AR标记！正在加载3D模型...');
			loadModel(); // 触发模型加载
		} else if (!camera.visible && markerWasVisible) {
			console.log('AR标记丢失');
		}
		
		// 更新标记状态
		markerWasVisible = camera.visible;
	})

	////////////////////////////////////////////////////////////////////////////////
	//          Create a ArMarkerControls
	////////////////////////////////////////////////////////////////////////////////



	// 初始化相机控制
	var markerControls = new THREEx.ArMarkerControls(arToolkitContext, camera, {
		type: 'pattern',
		patternUrl: THREEx.ArToolkitContext.baseURL + 'data/data/marker.patt',
		// 因为我们控制相机，所以设置changeMatrixMode为'cameraTransformMatrix'
		changeMatrixMode: 'cameraTransformMatrix'
	})
	// 由于使用了changeMatrixMode: 'cameraTransformMatrix'，初始时场景不可见
	scene.visible = false

	console.log('AR标记跟踪应用初始化完成');
	console.log('请将HIRO标记置于摄像头前以进行跟踪...');

	// 错误处理函数
	function handleError(error) {
		console.error('AR应用错误:', error);
		// 可以在这里添加用户友好的错误提示
	}

	// 清理函数，在组件卸载或页面关闭时调用
	function cleanup() {
		console.log('正在清理AR资源...');
		
		// 移除事件监听器
		document.removeEventListener('click', onDocumentClick);
		document.removeEventListener('touchstart', onDocumentClick);
		window.removeEventListener('resize', onResize);
		
		// 停止渲染循环
		cancelAnimationFrame(animationId);
		
		// 清理场景资源
		if (loadedModel) {
			scene.remove(loadedModel);
			// 这里可以添加更多的资源释放逻辑
		}
		
		// 停止AR追踪
		if (arToolkitContext && arToolkitContext.arController) {
			arToolkitContext.arController.dispose();
		}
		
		// 清理渲染器
		if (renderer) {
			renderer.dispose();
			document.body.removeChild(renderer.domElement);
		}
	}

	// 添加页面卸载时的清理
	window.addEventListener('beforeunload', cleanup);
	
	// 性能优化：限制帧率
	var lastRenderTime = 0;
	var frameRateLimit = 16; // 约60fps
	var animationId;

	//////////////////////////////////////////////////////////////////////////////////
	//		render the whole thing on the page
	//////////////////////////////////////////////////////////////////////////////////

	// 渲染场景
	onRenderFcts.push(function(){
		renderer.render(scene, camera);
	})

	// 处理鼠标/触摸点击事件
	function onDocumentClick(event) {
		// 防止默认事件
		event.preventDefault();
		
		// 计算鼠标在归一化设备坐标中的位置
		// 对于鼠标
		if (event.clientX !== undefined) {
			mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
		} 
		// 对于触摸事件
		else if (event.touches && event.touches[0]) {
			mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
			mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
		}
		
		// 更新射线投射器
		raycaster.setFromCamera(mouse, camera);
		
		// 计算物体和射线的焦点
		var intersects = raycaster.intersectObjects(scene.children, true);
		
		// 重置之前选中对象的颜色
		if (selectedObject && originalColor) {
			selectedObject.material.color.copy(originalColor);
			selectedObject = null;
			originalColor = null;
		}
		
		// 检查是否有物体被点击
		if (intersects.length > 0) {
			var intersect = intersects[0];
			var clickedObject = intersect.object;
			
			// 检查是否是我们的交互模型
			if (clickedObject.name && clickedObject.name.startsWith('interactive-')) {
				console.log('点击了交互对象:', clickedObject.name);
				
				// 保存原始颜色并更改颜色作为反馈
				selectedObject = clickedObject;
				originalColor = clickedObject.material.color.clone();
				clickedObject.material.color.set(0x00ff00); // 变为绿色作为选中状态
				
				// 为被点击的物体添加一个缩放动画
				var scaleUp = true;
				var originalScale = clickedObject.scale.clone();
				var animationSteps = 30;
				var currentStep = 0;
				
				var animateScale = function() {
					currentStep++;
					if (currentStep <= animationSteps) {
						var progress = currentStep / animationSteps;
						var scaleFactor;
						
						if (scaleUp) {
							// 放大到1.2倍
							scaleFactor = 1 + 0.2 * progress;
							if (progress >= 1) {
								scaleUp = false;
								currentStep = 0;
							}
						} else {
							// 缩小回原始大小
							scaleFactor = 1.2 - 0.2 * progress;
						}
						
						clickedObject.scale.set(
							originalScale.x * scaleFactor,
							originalScale.y * scaleFactor,
							originalScale.z * scaleFactor
						);
						
						requestAnimationFrame(animateScale);
					} else if (!scaleUp) {
						// 动画完成，恢复原始大小
						clickedObject.scale.copy(originalScale);
					}
				};
				
				animateScale();
			}
		}
	}
	
	// 添加事件监听器
	document.addEventListener('click', onDocumentClick, false);
	document.addEventListener('touchstart', onDocumentClick, false);
	
	// 运行渲染循环 - 带帧率限制
	function animate(nowMsec) {
		// 保存动画ID以便后续取消
		animationId = requestAnimationFrame(animate);
		
		// 帧率限制
		if (nowMsec - lastRenderTime >= frameRateLimit) {
			// 计算时间差
			var deltaMsec = Math.min(200, nowMsec - lastRenderTime);
			lastRenderTime = nowMsec;
			
			try {
				// 调用每个更新函数
				onRenderFcts.forEach(function(onRenderFct) {
					onRenderFct(deltaMsec/1000, nowMsec/1000);
				});
			} catch (error) {
				handleError(error);
			}
		}
	}
	
	// 开始渲染循环
	animate();
	
	// 为了更好的用户体验，添加一个简单的提示
	console.log('AR标记跟踪应用已准备就绪');
	console.log('提示：使用HIRO标记（项目中data/data/patt.hiro对应的图像）进行测试');
	console.log('在移动设备上，确保授予摄像头权限以获得最佳体验');
</script>
</body>